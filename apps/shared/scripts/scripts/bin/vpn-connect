#!/usr/bin/env bash

set -euo pipefail

# Paths
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
OTP_SCRIPT="$(command -v otp || echo "${SCRIPT_DIR}/otp")"
PRITUNL_CLIENT="/Applications/Pritunl.app/Contents/Resources/pritunl-client"
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/vpn-connect"
LAST_PROFILE_FILE="${CACHE_DIR}/last_profile"

# Check dependencies
check_dependencies() {
    local missing_deps=()
    
    if ! command -v fzf &> /dev/null; then
        missing_deps+=("fzf")
    fi
    
    if [[ ! -x "$OTP_SCRIPT" ]]; then
        echo "Error: OTP script not found at $OTP_SCRIPT" >&2
        exit 1
    fi
    
    if [[ ! -x "$PRITUNL_CLIENT" ]]; then
        echo "Error: pritunl-client not found at $PRITUNL_CLIENT" >&2
        echo "Install Pritunl: brew install pritunl" >&2
        exit 1
    fi
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        echo "Error: Missing dependencies: ${missing_deps[*]}" >&2
        echo "Install with: brew install ${missing_deps[*]}" >&2
        exit 1
    fi
}

# Get VPN profiles from pritunl-client
get_vpn_profiles() {
    # Get profile list and parse it
    # Format: ID | NAME | STATE | ...
    local profiles
    profiles=$("$PRITUNL_CLIENT" list 2>/dev/null)
    
    if [[ -z "$profiles" ]]; then
        echo "" >&2
        return 1
    fi
    
    # Parse the table output, skip header and borders
    # Extract ID and NAME columns (columns 1 and 2)
    echo "$profiles" | grep -v "^+" | tail -n +2 | while IFS='|' read -r _ id name state _; do
        # Trim whitespace
        id=$(echo "$id" | xargs)
        name=$(echo "$name" | xargs)
        state=$(echo "$state" | xargs)
        
        # Skip header row
        if [[ "$id" != "ID" && -n "$id" ]]; then
            echo "${id}|${name}|${state}"
        fi
    done
}

# Save the selected profile ID
save_last_profile() {
    local profile_id="$1"
    mkdir -p "$CACHE_DIR"
    echo "$profile_id" > "$LAST_PROFILE_FILE"
}

# Get the last selected profile ID
get_last_profile() {
    if [[ -f "$LAST_PROFILE_FILE" ]]; then
        cat "$LAST_PROFILE_FILE"
    fi
}

# Reorder profiles to put last selected first
reorder_profiles() {
    local profiles="$1"
    local last_profile="$2"
    
    if [[ -z "$last_profile" ]]; then
        echo "$profiles"
        return
    fi
    
    # Find the last selected profile line
    local last_line=$(echo "$profiles" | grep "^${last_profile}|")
    
    if [[ -z "$last_line" ]]; then
        # Last profile not found, return original order
        echo "$profiles"
        return
    fi
    
    # Put last profile first, then all others
    echo "$last_line"
    echo "$profiles" | grep -v "^${last_profile}|"
}

# Get OTP code
get_otp_code() {
    local otp_name="$1"
    local otp_output
    otp_output=$("$OTP_SCRIPT" get "$otp_name" 2>&1)
    
    if [[ $? -ne 0 ]]; then
        echo "Error: Failed to get OTP code" >&2
        exit 1
    fi
    
    # Extract the 6-digit code from output
    local code
    code=$(echo "$otp_output" | grep -oE '[0-9]{6}' | head -n 1)
    
    if [[ -z "$code" ]]; then
        echo "Error: Could not extract OTP code" >&2
        exit 1
    fi
    
    echo "$code"
}

# Get profile connection status
get_profile_status() {
    local profile_id="$1"
    
    # Get the "ONLINE FOR" column for this profile (column 6, not 5!)
    "$PRITUNL_CLIENT" list 2>/dev/null | grep -F "$profile_id" | awk -F'|' '{print $6}' | xargs
}

# Connect using pritunl-client start command
connect_vpn() {
    local profile_id="$1"
    local otp_code="$2"
    
    echo "Connecting to VPN..." >&2
    
    # Use pritunl-client to start the profile with OTP
    "$PRITUNL_CLIENT" start "$profile_id" --password "$otp_code" 2>&1
    
    local exit_code=$?
    
    if [[ $exit_code -ne 0 ]]; then
        echo "" >&2
        echo "Error: Failed to initiate VPN connection (exit code: $exit_code)" >&2
        return 1
    fi
    
    # Wait for connection to establish
    echo "Waiting for connection to establish..." >&2
    
    local max_wait=30
    local waited=0
    local connected=false
    
    while [[ $waited -lt $max_wait ]]; do
        local status=$(get_profile_status "$profile_id")
        
        # Check if status shows a time duration (e.g., "5 secs", "1 min", "2 hours")
        # or contains "sec", "min", "hour" which indicates connected
        if [[ "$status" == *"sec"* || "$status" == *"min"* || "$status" == *"hour"* ]]; then
            connected=true
            break
        elif [[ "$status" == "Connecting" || "$status" == "Disconnected" ]]; then
            # Still connecting, wait a bit
            sleep 1
            waited=$((waited + 1))
            echo -n "." >&2
        else
            # Unknown status, keep waiting
            sleep 1
            waited=$((waited + 1))
            echo -n "." >&2
        fi
    done
    
    echo "" >&2
    
    if [[ "$connected" == true ]]; then
        echo "✓ VPN connected successfully!" >&2
        
        # Show connection details
        "$PRITUNL_CLIENT" list 2>/dev/null | grep -F "$profile_id" | awk -F'|' '{
            gsub(/^[ \t]+|[ \t]+$/, "", $6);
            gsub(/^[ \t]+|[ \t]+$/, "", $7);
            gsub(/^[ \t]+|[ \t]+$/, "", $8);
            print "  Online for: " $6;
            print "  Server: " $7;
            print "  Client IP: " $8;
        }' >&2
        
        return 0
    else
        local final_status=$(get_profile_status "$profile_id")
        echo "Error: VPN connection timed out after ${max_wait} seconds" >&2
        echo "Current status: $final_status" >&2
        return 1
    fi
}

# Main
main() {
    local start_time=$(date +%s)
    
    check_dependencies
    
    echo "Fetching VPN profiles..." >&2
    local profiles
    profiles=$(get_vpn_profiles)
    
    if [[ -z "$profiles" ]]; then
        echo "Error: No VPN profiles found" >&2
        echo "" >&2
        echo "To add a profile:" >&2
        echo "  1. Visit https://vpn.infra.fazzfinancial.com/login" >&2
        echo "  2. Copy the profile URI from the website" >&2
        echo "  3. Run: $PRITUNL_CLIENT add <profile_uri>" >&2
        echo "" >&2
        read -p "Would you like to add a profile now? (y/n): " answer
        if [[ "$answer" == "y" || "$answer" == "Y" ]]; then
            read -p "Enter profile URI: " profile_uri
            if [[ -n "$profile_uri" ]]; then
                echo "Adding profile..." >&2
                "$PRITUNL_CLIENT" add "$profile_uri"
                echo "Profile added! Re-run this script to connect." >&2
            fi
        fi
        exit 1
    fi
    
    # Reorder profiles to put last selected first
    local last_profile=$(get_last_profile)
    profiles=$(reorder_profiles "$profiles" "$last_profile")
    
    # Format for fzf display: "name (state)"
    local profiles_display=""
    while IFS='|' read -r id name state; do
        profiles_display+="${name} [${state}]|${id}|${name}"$'\n'
    done <<< "$profiles"
    
    # Select profile using fzf
    local selected_display
    selected_display=$(echo "$profiles_display" | cut -d'|' -f1 | fzf --prompt="Select VPN profile: " --height=40% --reverse)
    
    if [[ -z "$selected_display" ]]; then
        echo "No profile selected" >&2
        exit 1
    fi
    
    # Extract profile ID from selection
    local profile_line
    profile_line=$(echo "$profiles_display" | grep -F "${selected_display}|" | head -n 1)
    
    local profile_id=$(echo "$profile_line" | cut -d'|' -f2)
    local profile_name=$(echo "$profile_line" | cut -d'|' -f3)
    
    # Save this as the last selected profile
    save_last_profile "$profile_id"
    
    echo "Selected: $profile_name" >&2
    echo "" >&2
    
    # Get OTP code
    echo "Fetching OTP code..." >&2
    local otp_code
    otp_code=$(get_otp_code "vpn")
    
    echo "✓ Got OTP: $otp_code" >&2
    echo "" >&2
    
    # Connect to VPN
    if ! connect_vpn "$profile_id" "$otp_code"; then
        exit 1
    fi
    
    # Calculate and display connection time
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    echo "" >&2
    echo "⏱️  Total connection time: ${duration} seconds" >&2
}

main "$@"
