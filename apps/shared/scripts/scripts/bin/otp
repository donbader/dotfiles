#!/usr/bin/env node
/**
 * Secure OTP Manager - Store and retrieve OTP secrets using macOS Keychain
 * 
 * This script manages TOTP (Time-based One-Time Password) secrets in macOS Keychain.
 * 
 * Requirements:
 *     macOS only - uses macOS Keychain (security command)
 * 
 * Usage:
 *     ./otp add <name> <secret>     Add/update OTP secret
 *     ./otp get <name>              Generate OTP code
 *     ./otp list                    List all services
 *     ./otp remove <name>           Remove a secret
 *     ./otp export                  Export all secrets (plaintext)
 *     ./otp clear-auth              Clear authentication cache
 * 
 * Example:
 *     ./otp add github JBSWY3DPEHPK3PXP
 *     ./otp get github
 *     # Output: Current OTP for 'github': 123456 (valid for 23 seconds)
 * 
 * Security:
 *     - Secrets stored securely in macOS Keychain
 *     - Keychain is encrypted and protected by macOS
 *     - Authentication cached for configurable timeout (default: 30 seconds)
 *     - Secrets accessible only to your user account
 * 
 * Configuration:
 *     AUTH_TIMEOUT - Authentication cache timeout in seconds (line 37)
 */

const crypto = require('crypto');
const { execSync } = require('child_process');
const readline = require('readline');
const fs = require('fs');

// Configuration
const KEYCHAIN_SERVICE_PREFIX = 'otp-manager';
const KEYCHAIN_AUTH_PREFIX = 'otp-manager-auth';
const AUTH_TIMEOUT = 24 * 60 * 60; // Authentication timeout in seconds

/**
 * Format seconds into human-readable time string
 */
function formatTimeout(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    const parts = [];
    if (hours > 0) parts.push(`${hours}h`);
    if (minutes > 0) parts.push(`${minutes}m`);
    if (secs > 0 || parts.length === 0) parts.push(`${secs}s`);

    return parts.join(' ');
}

/**
 * Store authentication timestamp in keychain
 */
function storeAuthTimestamp() {
    try {
        // Delete existing entry first (ignore errors)
        try {
            execSync(`security delete-generic-password -s "${KEYCHAIN_AUTH_PREFIX}" -a "timestamp" 2>/dev/null`);
        } catch (e) { }

        const timestamp = Date.now();
        execSync(`security add-generic-password -s "${KEYCHAIN_AUTH_PREFIX}" -a "timestamp" -w "${timestamp}"`, {
            stdio: 'pipe'
        });
    } catch (error) {
        // Silently fail
    }
}

/**
 * Check if authentication is still valid
 */
function isAuthValid() {
    try {
        const result = execSync(`security find-generic-password -s "${KEYCHAIN_AUTH_PREFIX}" -a "timestamp" -w 2>/dev/null`, {
            encoding: 'utf8',
            stdio: 'pipe'
        }).trim();

        const timestamp = parseInt(result, 10);
        const age = (Date.now() - timestamp) / 1000; // in seconds

        if (age > AUTH_TIMEOUT) {
            return false;
        }

        const remainingSeconds = Math.floor(AUTH_TIMEOUT - age);
        console.log(`(Authentication valid for ${formatTimeout(remainingSeconds)})`);

        return true;
    } catch (error) {
        return false;
    }
}

/**
 * Clear authentication timestamp
 */
function clearAuth() {
    try {
        execSync(`security delete-generic-password -s "${KEYCHAIN_AUTH_PREFIX}" -a "timestamp" 2>/dev/null`);
    } catch (e) { }
}

/**
 * Prompts for password input (hidden)
 */
function getPassword(prompt = 'Enter password to access OTP secrets: ') {
    return new Promise((resolve, reject) => {
        const { execSync } = require('child_process');

        // Use /dev/tty to ensure we can always read password even if stdout is redirected
        const ttyFd = fs.openSync('/dev/tty', 'r+');
        const input = fs.createReadStream(null, { fd: ttyFd });
        const output = fs.createWriteStream(null, { fd: ttyFd });

        // Write prompt
        output.write(prompt);

        // Disable echo using stty
        try {
            execSync('stty -echo', { stdio: ['inherit', 'inherit', 'inherit'] });
        } catch (e) {
            // If stty fails, continue anyway
        }

        let password = '';
        let resolved = false;

        input.on('data', (chunk) => {
            if (resolved) return;

            const str = chunk.toString();

            // Check for newline/return anywhere in the chunk
            const newlineIndex = str.search(/[\n\r]/);

            if (newlineIndex !== -1) {
                // Add everything before the newline to password
                password += str.substring(0, newlineIndex);

                // Re-enable echo
                try {
                    execSync('stty echo', { stdio: ['inherit', 'inherit', 'inherit'] });
                } catch (e) { }

                output.write('\n');
                input.destroy();
                output.destroy();

                resolved = true;

                // Validate password is not empty
                if (!password || password.length === 0) {
                    reject(new Error('Password cannot be empty'));
                } else {
                    resolve(password);
                }
            } else {
                password += str;
            }
        });

        input.on('error', (err) => {
            if (resolved) return;
            // Re-enable echo on error
            try {
                execSync('stty echo', { stdio: ['inherit', 'inherit', 'inherit'] });
            } catch (e) { }
            resolved = true;
            reject(err);
        });

        // Handle Ctrl+C
        const sigintHandler = () => {
            if (resolved) return;
            try {
                execSync('stty echo', { stdio: ['inherit', 'inherit', 'inherit'] });
            } catch (e) { }
            output.write('\n');
            resolved = true;
            reject(new Error('Cancelled'));
        };

        process.on('SIGINT', sigintHandler);
    });
}

/**
 * Verify keychain password and update auth timestamp
 */
async function authenticate() {
    if (isAuthValid()) {
        return true;
    }

    console.log(`(Authentication expired after ${formatTimeout(AUTH_TIMEOUT)})`);

    try {
        const password = await getPassword();

        // Verify password by trying to unlock the keychain and set partition list
        // This allows the trusted apps to access without prompts
        try {
            // First unlock the keychain
            execSync(`security unlock-keychain -p "${password.replace(/"/g, '\\"')}"`, {
                stdio: 'pipe'
            });

            // Set partition list for auth timestamp to allow access without prompts
            try {
                execSync(`security set-generic-password-partition-list -s "${KEYCHAIN_AUTH_PREFIX}" -a "timestamp" -k "${password.replace(/"/g, '\\"')}" 2>/dev/null`, {
                    stdio: 'pipe'
                });
            } catch (e) {
                // Ignore if item doesn't exist yet
            }

            // Password correct, store auth timestamp
            storeAuthTimestamp();
            console.log(`(Authentication successful - valid for ${formatTimeout(AUTH_TIMEOUT)})`);
            return true;
        } catch (error) {
            console.error('Incorrect password');
            return false;
        }
    } catch (error) {
        if (error.message === 'Cancelled') {
            throw error;
        }
        console.error(`Authentication failed: ${error.message}`);
        return false;
    }
}

/**
 * Store OTP secret in macOS Keychain
 */
function storeSecret(name, secret) {
    try {
        // Delete existing entry first (ignore errors)
        try {
            execSync(`security delete-generic-password -s "${KEYCHAIN_SERVICE_PREFIX}" -a "${name}" 2>/dev/null`);
        } catch (e) { }

        // Add secret to keychain
        // Access control will be set via set-generic-password-partition-list
        execSync(`security add-generic-password -s "${KEYCHAIN_SERVICE_PREFIX}" -a "${name}" -w "${secret}"`, {
            stdio: 'pipe'
        });
    } catch (error) {
        throw new Error(`Failed to store secret in keychain: ${error.message}`);
    }
}

/**
 * Retrieve OTP secret from macOS Keychain
 */
function getSecret(name) {
    try {
        // After set-generic-password-partition-list is called during authentication,
        // we can access items without prompts
        const result = execSync(`security find-generic-password -s "${KEYCHAIN_SERVICE_PREFIX}" -a "${name}" -w 2>/dev/null`, {
            encoding: 'utf8',
            stdio: 'pipe'
        }).trim();

        return result;
    } catch (error) {
        return null;
    }
}

/**
 * Delete OTP secret from macOS Keychain
 */
function deleteSecret(name) {
    try {
        execSync(`security delete-generic-password -s "${KEYCHAIN_SERVICE_PREFIX}" -a "${name}" 2>/dev/null`);
        return true;
    } catch (e) {
        return false;
    }
}

/**
 * List all OTP secrets from macOS Keychain
 */
function listSecrets() {
    try {
        // Use security dump-keychain to find all entries with our service name
        // 0x00000007 is the attribute code for "svce" (service)
        const result = execSync(`security dump-keychain 2>/dev/null | grep -A 2 '0x00000007 <blob>="${KEYCHAIN_SERVICE_PREFIX}"' | grep '"acct"<blob>=' | sed 's/.*"acct"<blob>="\\(.*\\)".*/\\1/'`, {
            encoding: 'utf8',
            stdio: 'pipe'
        }).trim();

        if (!result) {
            return [];
        }

        return result.split('\n').filter(line => line.length > 0);
    } catch (error) {
        return [];
    }
}

/**
 * Prompts for confirmation
 */
function confirm(prompt) {
    return new Promise((resolve) => {
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        rl.question(prompt, (answer) => {
            rl.close();
            resolve(answer.toLowerCase() === 'yes');
        });
    });
}

/**
 * Base32 decoder for TOTP secrets
 */
function base32Decode(input) {
    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
    const cleanInput = input.replace(/=+$/, '').toUpperCase();

    let bits = '';
    for (let i = 0; i < cleanInput.length; i++) {
        const val = alphabet.indexOf(cleanInput[i]);
        if (val === -1) throw new Error('Invalid base32 character');
        bits += val.toString(2).padStart(5, '0');
    }

    const bytes = [];
    for (let i = 0; i + 8 <= bits.length; i += 8) {
        bytes.push(parseInt(bits.slice(i, i + 8), 2));
    }

    return Buffer.from(bytes);
}

/**
 * Generate TOTP code
 */
function generateTOTP(secret, timeStep = 30) {
    try {
        // Clean and decode secret
        const cleanSecret = secret.replace(/\s/g, '').toUpperCase();
        const key = base32Decode(cleanSecret);

        // Calculate time counter
        const now = Math.floor(Date.now() / 1000);
        const counter = Math.floor(now / timeStep);

        // Create counter buffer (8 bytes, big-endian)
        const counterBuffer = Buffer.alloc(8);
        counterBuffer.writeBigInt64BE(BigInt(counter));

        // Generate HMAC
        const hmac = crypto.createHmac('sha1', key);
        hmac.update(counterBuffer);
        const digest = hmac.digest();

        // Dynamic truncation
        const offset = digest[digest.length - 1] & 0x0f;
        const code = (
            ((digest[offset] & 0x7f) << 24) |
            ((digest[offset + 1] & 0xff) << 16) |
            ((digest[offset + 2] & 0xff) << 8) |
            (digest[offset + 3] & 0xff)
        ) % 1000000;

        // Time remaining
        const timeRemaining = timeStep - (now % timeStep);

        return {
            code: code.toString().padStart(6, '0'),
            timeRemaining
        };
    } catch (error) {
        throw new Error('Invalid TOTP secret format');
    }
}

/**
 * Add or update an OTP secret
 */
async function addSecret(name, secret) {
    try {
        // Validate the secret by trying to generate a TOTP
        const cleanSecret = secret.replace(/\s/g, '').toUpperCase();
        generateTOTP(cleanSecret); // Will throw if invalid

        // Get password to authorize the partition list update
        const password = await getPassword('Enter keychain password to save secret: ');

        // Verify password first
        try {
            execSync(`security unlock-keychain -p "${password.replace(/"/g, '\\"')}"`, {
                stdio: 'pipe'
            });
        } catch (error) {
            console.error('Incorrect password');
            return false;
        }

        // Store the secret
        storeSecret(name, cleanSecret);

        // Set partition list to allow access without prompts going forward
        try {
            execSync(`security set-generic-password-partition-list -s "${KEYCHAIN_SERVICE_PREFIX}" -a "${name}" -k "${password.replace(/"/g, '\\"')}" 2>/dev/null`, {
                stdio: 'pipe'
            });
        } catch (e) {
            // Continue even if this fails
        }

        console.log(`✓ Secret for '${name}' saved successfully to Keychain`);
        return true;
    } catch (error) {
        if (error.message === 'Cancelled') {
            throw error;
        }
        console.error(`Error: ${error.message}`);
        return false;
    }
}

/**
 * Get current OTP code for a service
 */
async function getOTP(name) {
    try {
        // Check authentication first
        const authenticated = await authenticate();
        if (!authenticated) {
            return false;
        }

        const secret = getSecret(name);

        if (!secret) {
            console.error(`Error: No secret found for '${name}'`);
            console.error(`Use 'otp list' to see available services`);
            return false;
        }

        const { code, timeRemaining } = generateTOTP(secret);

        console.log(`\nCurrent OTP for '${name}': ${code}`);
        console.log(`Valid for ${timeRemaining} seconds`);
        return true;
    } catch (error) {
        console.error(`Error: ${error.message}`);
        return false;
    }
}

/**
 * List all stored services
 */
async function listServices() {
    try {
        // Check authentication first
        const authenticated = await authenticate();
        if (!authenticated) {
            return false;
        }

        const services = listSecrets();

        if (services.length === 0) {
            console.log('No services stored yet.');
            return true;
        }

        console.log(`\nStored services (${services.length}):`);
        services.sort().forEach(name => {
            console.log(`  - ${name}`);
        });
        return true;
    } catch (error) {
        console.error(`Error: ${error.message}`);
        return false;
    }
}

/**
 * Remove a secret
 */
async function removeSecret(name) {
    try {
        const success = deleteSecret(name);

        if (!success) {
            console.error(`Error: No secret found for '${name}'`);
            return false;
        }

        console.log(`✓ Secret for '${name}' removed successfully from Keychain`);
        return true;
    } catch (error) {
        console.error(`Error: ${error.message}`);
        return false;
    }
}

/**
 * Export all secrets in plaintext
 */
async function exportSecrets() {
    try {
        // Check authentication first
        const authenticated = await authenticate();
        if (!authenticated) {
            return false;
        }

        console.log('\n⚠️  WARNING: This will display all secrets in plaintext!');
        const confirmed = await confirm('Type \'yes\' to continue: ');

        if (!confirmed) {
            console.log('Export cancelled.');
            return false;
        }

        const services = listSecrets();

        console.log('\n' + '='.repeat(60));
        console.log('SECRETS (keep this secure!):');
        console.log('='.repeat(60));

        services.sort().forEach(name => {
            const secret = getSecret(name);
            if (secret) {
                console.log(`${name}: ${secret}`);
            }
        });

        console.log('='.repeat(60) + '\n');
        return true;
    } catch (error) {
        console.error(`Error: ${error.message}`);
        return false;
    }
}

/**
 * Print usage information
 */
function printUsage() {
    console.log(`
Secure OTP Manager (using macOS Keychain)

Usage:
    otp add <name> <secret>     Add/update OTP secret
    otp get <name>              Generate OTP code
    otp list                    List all services
    otp remove <name>           Remove a secret
    otp export                  Export all secrets (plaintext)
    otp clear-auth              Clear ${formatTimeout(AUTH_TIMEOUT)} authentication

Examples:
    otp add github JBSWY3DPEHPK3PXP
    otp get github
    otp list
    `);
}

/**
 * Main entry point
 */
async function main() {
    // Check if running on macOS
    if (process.platform !== 'darwin') {
        console.error('Error: This script only works on macOS (requires Keychain)');
        console.error('Platform detected:', process.platform);
        process.exit(1);
    }

    const args = process.argv.slice(2).filter(arg => !arg.startsWith('--'));

    if (args.length === 0) {
        printUsage();
        process.exit(1);
    }

    const command = args[0].toLowerCase();

    try {
        let success = false;

        switch (command) {
            case 'add':
                if (args.length !== 3) {
                    console.error('Usage: otp add <name> <secret>');
                    process.exit(1);
                }
                success = await addSecret(args[1], args[2]);
                break;

            case 'get':
                if (args.length !== 2) {
                    console.error('Usage: otp get <name>');
                    process.exit(1);
                }
                success = await getOTP(args[1]);
                break;

            case 'list':
                success = await listServices();
                break;

            case 'remove':
                if (args.length !== 2) {
                    console.error('Usage: otp remove <name>');
                    process.exit(1);
                }
                success = await removeSecret(args[1]);
                break;

            case 'export':
                success = await exportSecrets();
                break;

            case 'clear-auth':
                clearAuth();
                console.log('✓ Authentication cleared (will require password on next access)');
                success = true;
                break;

            default:
                console.error(`Error: Unknown command '${command}'`);
                printUsage();
                process.exit(1);
        }

        process.exit(success ? 0 : 1);
    } catch (error) {
        if (error.message === 'Cancelled') {
            console.log('\n\nOperation cancelled.');
            process.exit(1);
        }
        console.error(`\nError: ${error.message}`);
        process.exit(1);
    }
}

// Run main function
main();
