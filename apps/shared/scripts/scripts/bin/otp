#!/usr/bin/env node
/**
 * Secure OTP Manager - Store and retrieve OTP secrets using macOS Keychain
 * 
 * This script manages TOTP (Time-based One-Time Password) secrets in macOS Keychain.
 * 
 * Requirements:
 *     None - uses built-in Node.js crypto module and macOS Keychain
 * 
 * Usage:
 *     ./otp add <name> <secret>     Add/update OTP secret
 *     ./otp get <name>              Generate OTP code
 *     ./otp list                    List all services
 *     ./otp remove <name>           Remove a secret
 *     ./otp export                  Export all secrets (plaintext)
 * 
 * Example:
 *     ./otp add github JBSWY3DPEHPK3PXP
 *     ./otp get github
 *     # Output: Current OTP for 'github': 123456 (valid for 23 seconds)
 * 
 * Security:
 *     - Secrets stored securely in macOS Keychain
 *     - Keychain is encrypted and protected by macOS
 *     - No master password required
 *     - Secrets accessible only to your user account
 */

const crypto = require('crypto');
const { execSync } = require('child_process');
const readline = require('readline');
const fs = require('fs');

// Configuration
const KEYCHAIN_SERVICE_PREFIX = 'otp-manager';
const KEYCHAIN_AUTH_PREFIX = 'otp-manager-auth';
const AUTH_TIMEOUT = 24 * 60 * 60; // 24 hours in seconds

/**
 * Store authentication timestamp in keychain
 */
function storeAuthTimestamp() {
    try {
        // Delete existing entry first (ignore errors)
        try {
            execSync(`security delete-generic-password -s "${KEYCHAIN_AUTH_PREFIX}" -a "timestamp" 2>/dev/null`);
        } catch (e) {}
        
        const timestamp = Date.now();
        execSync(`security add-generic-password -s "${KEYCHAIN_AUTH_PREFIX}" -a "timestamp" -w "${timestamp}" -A`, {
            stdio: 'pipe'
        });
    } catch (error) {
        // Silently fail
    }
}

/**
 * Check if authentication is still valid
 */
function isAuthValid() {
    try {
        const result = execSync(`security find-generic-password -s "${KEYCHAIN_AUTH_PREFIX}" -a "timestamp" -w 2>/dev/null`, {
            encoding: 'utf8',
            stdio: 'pipe'
        }).trim();
        
        const timestamp = parseInt(result, 10);
        const age = (Date.now() - timestamp) / 1000; // in seconds
        
        if (age > AUTH_TIMEOUT) {
            return false;
        }
        
        const hoursRemaining = Math.floor((AUTH_TIMEOUT - age) / 3600);
        const minutesRemaining = Math.floor(((AUTH_TIMEOUT - age) % 3600) / 60);
        console.log(`(Authentication valid for ${hoursRemaining}h ${minutesRemaining}m)`);
        
        return true;
    } catch (error) {
        return false;
    }
}

/**
 * Clear authentication timestamp
 */
function clearAuth() {
    try {
        execSync(`security delete-generic-password -s "${KEYCHAIN_AUTH_PREFIX}" -a "timestamp" 2>/dev/null`);
    } catch (e) {}
}

/**
 * Prompts for password input (hidden)
 */
function getPassword(prompt = 'Enter password to access OTP secrets: ') {
    return new Promise((resolve, reject) => {
        const { execSync } = require('child_process');
        
        // Use /dev/tty to ensure we can always read password even if stdout is redirected
        const ttyFd = fs.openSync('/dev/tty', 'r+');
        const input = fs.createReadStream(null, { fd: ttyFd });
        const output = fs.createWriteStream(null, { fd: ttyFd });
        
        // Write prompt
        output.write(prompt);
        
        // Disable echo using stty
        try {
            execSync('stty -echo', { stdio: ['inherit', 'inherit', 'inherit'] });
        } catch (e) {
            // If stty fails, continue anyway
        }
        
        let password = '';
        let resolved = false;
        
        input.on('data', (chunk) => {
            if (resolved) return;
            
            const str = chunk.toString();
            
            // Check for newline/return anywhere in the chunk
            const newlineIndex = str.search(/[\n\r]/);
            
            if (newlineIndex !== -1) {
                // Add everything before the newline to password
                password += str.substring(0, newlineIndex);
                
                // Re-enable echo
                try {
                    execSync('stty echo', { stdio: ['inherit', 'inherit', 'inherit'] });
                } catch (e) {}
                
                output.write('\n');
                input.destroy();
                output.destroy();
                
                resolved = true;
                
                // Validate password is not empty
                if (!password || password.length === 0) {
                    reject(new Error('Password cannot be empty'));
                } else {
                    resolve(password);
                }
            } else {
                password += str;
            }
        });
        
        input.on('error', (err) => {
            if (resolved) return;
            // Re-enable echo on error
            try {
                execSync('stty echo', { stdio: ['inherit', 'inherit', 'inherit'] });
            } catch (e) {}
            resolved = true;
            reject(err);
        });
        
        // Handle Ctrl+C
        const sigintHandler = () => {
            if (resolved) return;
            try {
                execSync('stty echo', { stdio: ['inherit', 'inherit', 'inherit'] });
            } catch (e) {}
            output.write('\n');
            resolved = true;
            reject(new Error('Cancelled'));
        };
        
        process.on('SIGINT', sigintHandler);
    });
}

/**
 * Verify keychain password and update auth timestamp
 */
async function authenticate() {
    if (isAuthValid()) {
        return true;
    }
    
    console.log('(Authentication expired after 24 hours)');
    
    try {
        const password = await getPassword();
        
        // Verify password by trying to unlock the keychain
        try {
            execSync(`security unlock-keychain -p "${password.replace(/"/g, '\\"')}"`, {
                stdio: 'pipe'
            });
            
            // Password correct, store auth timestamp
            storeAuthTimestamp();
            console.log('(Authentication successful - valid for 24 hours)');
            return true;
        } catch (error) {
            console.error('Incorrect password');
            return false;
        }
    } catch (error) {
        if (error.message === 'Cancelled') {
            throw error;
        }
        console.error(`Authentication failed: ${error.message}`);
        return false;
    }
}

/**
 * Store OTP secret in macOS Keychain
 */
function storeSecret(name, secret) {
    try {
        // Delete existing entry first (ignore errors)
        try {
            execSync(`security delete-generic-password -s "${KEYCHAIN_SERVICE_PREFIX}" -a "${name}" 2>/dev/null`);
        } catch (e) {}
        
        // Add secret to keychain
        // -A allows all applications to access this item without prompting
        execSync(`security add-generic-password -s "${KEYCHAIN_SERVICE_PREFIX}" -a "${name}" -w "${secret}" -A`, {
            stdio: 'pipe'
        });
    } catch (error) {
        throw new Error(`Failed to store secret in keychain: ${error.message}`);
    }
}

/**
 * Retrieve OTP secret from macOS Keychain
 */
function getSecret(name) {
    try {
        const result = execSync(`security find-generic-password -s "${KEYCHAIN_SERVICE_PREFIX}" -a "${name}" -w 2>/dev/null`, {
            encoding: 'utf8',
            stdio: 'pipe'
        }).trim();
        
        return result;
    } catch (error) {
        return null;
    }
}

/**
 * Delete OTP secret from macOS Keychain
 */
function deleteSecret(name) {
    try {
        execSync(`security delete-generic-password -s "${KEYCHAIN_SERVICE_PREFIX}" -a "${name}" 2>/dev/null`);
        return true;
    } catch (e) {
        return false;
    }
}

/**
 * List all OTP secrets from macOS Keychain
 */
function listSecrets() {
    try {
        // Use security dump-keychain to find all entries with our service name
        // 0x00000007 is the attribute code for "svce" (service)
        const result = execSync(`security dump-keychain 2>/dev/null | grep -A 2 '0x00000007 <blob>="${KEYCHAIN_SERVICE_PREFIX}"' | grep '"acct"<blob>=' | sed 's/.*"acct"<blob>="\\(.*\\)".*/\\1/'`, {
            encoding: 'utf8',
            stdio: 'pipe'
        }).trim();
        
        if (!result) {
            return [];
        }
        
        return result.split('\n').filter(line => line.length > 0);
    } catch (error) {
        return [];
    }
}

/**
 * Prompts for confirmation
 */
function confirm(prompt) {
    return new Promise((resolve) => {
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        rl.question(prompt, (answer) => {
            rl.close();
            resolve(answer.toLowerCase() === 'yes');
        });
    });
}

/**
 * Base32 decoder for TOTP secrets
 */
function base32Decode(input) {
    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
    const cleanInput = input.replace(/=+$/, '').toUpperCase();
    
    let bits = '';
    for (let i = 0; i < cleanInput.length; i++) {
        const val = alphabet.indexOf(cleanInput[i]);
        if (val === -1) throw new Error('Invalid base32 character');
        bits += val.toString(2).padStart(5, '0');
    }
    
    const bytes = [];
    for (let i = 0; i + 8 <= bits.length; i += 8) {
        bytes.push(parseInt(bits.slice(i, i + 8), 2));
    }
    
    return Buffer.from(bytes);
}

/**
 * Generate TOTP code
 */
function generateTOTP(secret, timeStep = 30) {
    try {
        // Clean and decode secret
        const cleanSecret = secret.replace(/\s/g, '').toUpperCase();
        const key = base32Decode(cleanSecret);
        
        // Calculate time counter
        const now = Math.floor(Date.now() / 1000);
        const counter = Math.floor(now / timeStep);
        
        // Create counter buffer (8 bytes, big-endian)
        const counterBuffer = Buffer.alloc(8);
        counterBuffer.writeBigInt64BE(BigInt(counter));
        
        // Generate HMAC
        const hmac = crypto.createHmac('sha1', key);
        hmac.update(counterBuffer);
        const digest = hmac.digest();
        
        // Dynamic truncation
        const offset = digest[digest.length - 1] & 0x0f;
        const code = (
            ((digest[offset] & 0x7f) << 24) |
            ((digest[offset + 1] & 0xff) << 16) |
            ((digest[offset + 2] & 0xff) << 8) |
            (digest[offset + 3] & 0xff)
        ) % 1000000;
        
        // Time remaining
        const timeRemaining = timeStep - (now % timeStep);
        
        return {
            code: code.toString().padStart(6, '0'),
            timeRemaining
        };
    } catch (error) {
        throw new Error('Invalid TOTP secret format');
    }
}

/**
 * Add or update an OTP secret
 */
async function addSecret(name, secret) {
    try {
        // Validate the secret by trying to generate a TOTP
        const cleanSecret = secret.replace(/\s/g, '').toUpperCase();
        generateTOTP(cleanSecret); // Will throw if invalid
        
        storeSecret(name, cleanSecret);
        
        console.log(`✓ Secret for '${name}' saved successfully to Keychain`);
        return true;
    } catch (error) {
        console.error(`Error: ${error.message}`);
        return false;
    }
}

/**
 * Get current OTP code for a service
 */
async function getOTP(name) {
    try {
        // Check authentication first
        const authenticated = await authenticate();
        if (!authenticated) {
            return false;
        }
        
        const secret = getSecret(name);
        
        if (!secret) {
            console.error(`Error: No secret found for '${name}'`);
            console.error(`Use 'otp list' to see available services`);
            return false;
        }
        
        const { code, timeRemaining } = generateTOTP(secret);
        
        console.log(`\nCurrent OTP for '${name}': ${code}`);
        console.log(`Valid for ${timeRemaining} seconds`);
        return true;
    } catch (error) {
        console.error(`Error: ${error.message}`);
        return false;
    }
}

/**
 * List all stored services
 */
async function listServices() {
    try {
        // Check authentication first
        const authenticated = await authenticate();
        if (!authenticated) {
            return false;
        }
        
        const services = listSecrets();
        
        if (services.length === 0) {
            console.log('No services stored yet.');
            return true;
        }
        
        console.log(`\nStored services (${services.length}):`);
        services.sort().forEach(name => {
            console.log(`  - ${name}`);
        });
        return true;
    } catch (error) {
        console.error(`Error: ${error.message}`);
        return false;
    }
}

/**
 * Remove a secret
 */
async function removeSecret(name) {
    try {
        const success = deleteSecret(name);
        
        if (!success) {
            console.error(`Error: No secret found for '${name}'`);
            return false;
        }
        
        console.log(`✓ Secret for '${name}' removed successfully from Keychain`);
        return true;
    } catch (error) {
        console.error(`Error: ${error.message}`);
        return false;
    }
}

/**
 * Export all secrets in plaintext
 */
async function exportSecrets() {
    try {
        // Check authentication first
        const authenticated = await authenticate();
        if (!authenticated) {
            return false;
        }
        
        console.log('\n⚠️  WARNING: This will display all secrets in plaintext!');
        const confirmed = await confirm('Type \'yes\' to continue: ');
        
        if (!confirmed) {
            console.log('Export cancelled.');
            return false;
        }
        
        const services = listSecrets();
        
        console.log('\n' + '='.repeat(60));
        console.log('SECRETS (keep this secure!):');
        console.log('='.repeat(60));
        
        services.sort().forEach(name => {
            const secret = getSecret(name);
            if (secret) {
                console.log(`${name}: ${secret}`);
            }
        });
        
        console.log('='.repeat(60) + '\n');
        return true;
    } catch (error) {
        console.error(`Error: ${error.message}`);
        return false;
    }
}

/**
 * Print usage information
 */
function printUsage() {
    console.log(`
Secure OTP Manager (using macOS Keychain)

Usage:
    otp add <name> <secret>     Add/update OTP secret
    otp get <name>              Generate OTP code
    otp list                    List all services
    otp remove <name>           Remove a secret
    otp export                  Export all secrets (plaintext)
    otp clear-auth              Clear 24-hour authentication

Examples:
    otp add github JBSWY3DPEHPK3PXP
    otp get github
    otp list
    `);
}

/**
 * Main entry point
 */
async function main() {
    const args = process.argv.slice(2).filter(arg => !arg.startsWith('--'));
    
    if (args.length === 0) {
        printUsage();
        process.exit(1);
    }
    
    const command = args[0].toLowerCase();
    
    try {
        let success = false;
        
        switch (command) {
            case 'add':
                if (args.length !== 3) {
                    console.error('Usage: otp add <name> <secret>');
                    process.exit(1);
                }
                success = await addSecret(args[1], args[2]);
                break;
            
            case 'get':
                if (args.length !== 2) {
                    console.error('Usage: otp get <name>');
                    process.exit(1);
                }
                success = await getOTP(args[1]);
                break;
            
            case 'list':
                success = await listServices();
                break;
            
            case 'remove':
                if (args.length !== 2) {
                    console.error('Usage: otp remove <name>');
                    process.exit(1);
                }
                success = await removeSecret(args[1]);
                break;
            
            case 'export':
                success = await exportSecrets();
                break;
            
            case 'clear-auth':
                clearAuth();
                console.log('✓ Authentication cleared (will require password on next access)');
                success = true;
                break;
            
            default:
                console.error(`Error: Unknown command '${command}'`);
                printUsage();
                process.exit(1);
        }
        
        process.exit(success ? 0 : 1);
    } catch (error) {
        if (error.message === 'Cancelled') {
            console.log('\n\nOperation cancelled.');
            process.exit(1);
        }
        console.error(`\nError: ${error.message}`);
        process.exit(1);
    }
}

// Run main function
main();
