# Reusable GitHub CLI Commands for Reviews

This file centralizes reusable `gh` CLI commands used by the `git:review-pr-v2` workflow.

Use these as building blocks inside phases (fetching PR info, creating reviews with inline comments, and handling re-reviews) instead of re-inventing adâ€‘hoc commands.

---

## Core Setup

```bash
# Get repository owner/name in "owner/repo" form
repo_info=$(gh repo view --json owner,name -q '.owner.login + "/" + .name')
owner=$(echo "$repo_info" | cut -d'/' -f1)
repo=$(echo "$repo_info" | cut -d'/' -f2)

# Option A: PR number from URL argument
#   /git:review-pr-v2 https://github.com/OWNER/REPO/pull/123
if [ -n "$1" ]; then
  pr_number=$(echo "$1" | grep -oE '[0-9]+$')
else
  # Option B: PR for current branch (auto-detect)
  pr_number=$(gh pr view --json number -q .number 2>/dev/null)
fi

if [ -z "$pr_number" ]; then
  echo "ERROR: No PR found. Provide URL or ensure current branch has a PR."
  exit 1
fi
```

> Optional: To manually test commands against a specific PR without relying on the current checkout, you can set:
>
> ```bash
> repo_info="payfazz/straitsx-blockchain"
> owner="payfazz"
> repo="straitsx-blockchain"
> pr_number=2959
> ```

---

## Fetching PR Metadata and Diff

These commands are the canonical way to fetch PR metadata, review history, threads, and diff.

```bash
# Assumes repo_info, owner, repo, pr_number already set

# Fetch all key PR information in one chained command
echo "=== PR_NUMBER ===" && echo "$pr_number" && \
echo "=== PR_METADATA ===" && \
  gh pr view "$pr_number" --json title,body,author,url && \

echo "=== FILES_CHANGED ===" && \
  gh pr view "$pr_number" --json files \
    -q '.files[] | "\(.path) (+\(.additions)/-\(.deletions))"' && \

echo "=== REVIEW_THREADS_AND_HISTORY ===" && \
  gh api graphql -f query='
    query($owner: String!, $repo: String!, $pr: Int!) {
      repository(owner: $owner, name: $repo) {
        pullRequest(number: $pr) {
          reviewThreads(first: 100) {
            nodes {
              id
              isResolved
              comments(first: 10) {
                nodes {
                  databaseId
                  author { login }
                  body
                  path
                  line
                }
              }
            }
          }
          reviews(last: 100, states: COMMENTED) {
            nodes {
              body
              commit { oid }
              createdAt
            }
          }
        }
      }
    }' -f owner="$owner" -f repo="$repo" -F pr="$pr_number" && \

echo "=== CURRENT_COMMIT ===" && git rev-parse HEAD && \

echo "=== PR_DIFF ===" && \
  gh pr diff "$pr_number"
```

---

## Creating a Review With Inline Comments

**Goal**: Post a single review that includes:
- A summary body (overall review)
- One or more **inline comments** attached to specific file locations

Use the REST endpoint `POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews` via `gh api`.

```bash
# 1) Build the overall review body on disk
cat > /tmp/review_body.txt <<'EOF'
## Overall Review

**Assessment**: [2-3 sentences]

**Strengths**:
- [Specific praise]

**Review breakdown**:
- ðŸš¨ [X] Critical issues
- âš ï¸ [X] Important improvements
- ðŸ’¡ [X] Suggestions

**Future Considerations** (non-blockers):
- [Out-of-scope suggestions]

---
*ðŸ¤– Generated by OpenCode*
EOF

# 2) Post a single review with summary + inline comments
# NOTE: comments must be valid JSON array-of-objects

comments_json='[
  {
    "path": "src/auth.ts",         # file path relative to repo root
    "line": 42,                     # target line in the HEAD commit
    "side": "RIGHT",               # comment on the new code
    "body": "ðŸš¨ **Critical - Security**\n\n**Issue**: SQL injection vulnerability\n\n**Fix**:\n```suggestion\nconst query = "SELECT * FROM users WHERE id = ?";\nconst result = await db.query(query, [userId]);\n```\n\n**Learning**: Always use parameterized queries to prevent SQL injection\n\n---\n*ðŸ¤– Generated by OpenCode*"
  }
]'

# 3) Call GitHub's Create Review API via gh

gh api "repos/${repo_info}/pulls/${pr_number}/reviews" \
  --method POST \
  -f event=COMMENT \
  -F body=@/tmp/review_body.txt \
  -f comments="$comments_json"

rm /tmp/review_body.txt
```

**Key details for inline comments**:
- Use **`path` + `line` + `side`** for line-based comments on the latest commit
- `side` should almost always be `"RIGHT"` (the new code on the PR branch)
- `comments` must be a valid JSON array-of-objects string when passed via `-f comments="..."`
- Include the OpenCode watermark at the end of each comment body

---

## Replying in a Thread and Resolving via GraphQL (Re-Review)

Used when re-reviewing unresolved OpenCode threads.

```bash
# 1) Fetch review threads with resolution status via GraphQL
thread_data=$(gh api graphql -f query='
  query($owner: String!, $repo: String!, $pr: Int!) {
    repository(owner: $owner, name: $repo) {
      pullRequest(number: $pr) {
        reviewThreads(first: 100) {
          nodes {
            id
            isResolved
            comments(first: 10) {
              nodes {
                databaseId
                author { login }
                body
                path
                line
              }
            }
          }
        }
      }
    }
  }' -f owner="$owner" -f repo="$repo" -F pr="$pr_number")

# 2) Extract ONLY unresolved OpenCode-authored threads
unresolved_threads=$(echo "$thread_data" | jq -r '
  .data.repository.pullRequest.reviewThreads.nodes[] |
  select(.isResolved == false) |
  select(.comments.nodes[0].body | contains("ðŸ¤– Generated by OpenCode")) |
  {
    threadId: .id,
    commentId: .comments.nodes[0].databaseId,
    path: .comments.nodes[0].path,
    line: .comments.nodes[0].line
  }')

# 3) For each unresolved thread, reply + (optionally) resolve when satisfied

echo "$unresolved_threads" | jq -c '.' | while read -r thread; do
  thread_id=$(echo "$thread" | jq -r '.threadId')
  comment_id=$(echo "$thread" | jq -r '.commentId')

  # Example: reply in-thread confirming fix
  gh api "repos/${repo_info}/pulls/${pr_number}/comments" \
    --method POST \
    --field body="âœ… **Verified - Addressed**

The issue has been fixed. The code now:
[specific verification of what changed]

Marking as resolved.

---
*ðŸ¤– Re-verified by OpenCode*" \
    --field in_reply_to="$comment_id"

  # Mark thread as resolved (only if truly satisfied)
  gh api graphql -f query='
    mutation($threadId: ID!) {
      resolveReviewThread(input: {threadId: $threadId}) {
        thread { isResolved }
      }
    }' -f threadId="$thread_id"

done
```

---

## Standalone Verification Summary Comment (Re-Review)

When all unresolved issues have been verified as fixed and there are no new issues, post a standalone summary (not a review approval).

```bash
if [ "$all_satisfied" = true ] && [ "$has_new_comments" = false ]; then
  gh pr comment "$pr_number" --body "## âœ… Re-Review Complete - All Concerns Addressed

**All Issues Resolved**:
- âœ… All [X] previous threads verified and resolved
- âœ… No new issues found in recent changes

**Verification Summary**:
| Original Issue | File:Line | Status | Verification |
|---------------|-----------|--------|--------------|
| [issue 1] | file.ts:42 | âœ… Resolved | [how it was fixed] |
| [issue 2] | file.go:57 | âœ… Resolved | [how it was fixed] |

All feedback has been satisfactorily implemented. **Ready for human approval**.

---
*ðŸ¤– Re-reviewed by OpenCode*"
fi
```

**Reminder**: The automation should **never** call `gh pr review --approve`. Always leave formal approval to a human reviewer.
