# Phase 7: Post Review

**CRITICAL RULES**:
- âœ… Post ALL comments + summary in ONE review via GitHub API
- âœ… Every review MUST include at least one inline comment OR be a standalone comment
- âœ… For re-reviews: Resolve addressed comments and post verification
- âœ… NEVER directly approve - always leave approval to human reviewer
- âŒ NEVER post summary-only reviews (cannot be deleted via API)
- âŒ NEVER use `gh pr review --comment` separately

## For First Reviews

For the canonical `gh` CLI patterns used here (and in other phases), see **@~/.config/opencode/command/review-pr-v2/gh-commands.md**.

```bash
# Get repository info
repo_info=$(gh repo view --json owner,name -q '.owner.login + "/" + .name')

# Create review body with ALL summary content
cat > /tmp/review_body.txt <<'EOF'
## Overall Review

**Assessment**: [2-3 sentences]

**Strengths**:
- [Specific praise]

**Review breakdown**:
- ðŸš¨ [X] Critical issues
- âš ï¸ [X] Important improvements
- ðŸ’¡ [X] Suggestions

**Future Considerations** (non-blockers):
- [Out-of-scope suggestions]

---
*ðŸ¤– Generated by OpenCode*
EOF

# Build inline comments payload (JSON string)
comments_json='[
  {
    "path": "src/auth.ts",         # file path relative to repo root
    "line": 42,                     # target line in the latest commit
    "side": "RIGHT",               # always comment on the new code
    "body": "ðŸš¨ **Critical - Security**\n\n**Issue**: SQL injection vulnerability\n\n**Fix**:\n```suggestion\nconst query = \"SELECT * FROM users WHERE id = ?\";\nconst result = await db.query(query, [userId]);\n```\n\n**Learning**: Always use parameterized queries to prevent SQL injection\n\n---\n*ðŸ¤– Generated by OpenCode*"
  }
]'

# Post review using gh api (summary + inline comments in ONE request)
gh api "repos/${repo_info}/pulls/${pr_number}/reviews" \
  --method POST \
  -f event=COMMENT \
  -F body=@/tmp/review_body.txt \
  -f comments="$comments_json"

rm /tmp/review_body.txt
```
## For Re-Reviews (Autonomous Verification)

```bash
# Get repository info
repo_info=$(gh repo view --json owner,name -q '.owner.login + "/" + .name')
owner=$(echo "$repo_info" | cut -d'/' -f1)
repo=$(echo "$repo_info" | cut -d'/' -f2)

# CRITICAL: Fetch review threads with resolution status using GraphQL
# This is the ONLY reliable way to determine if a thread is truly resolved
thread_data=$(gh api graphql -f query='
  query($owner: String!, $repo: String!, $pr: Int!) {
    repository(owner: $owner, name: $repo) {
      pullRequest(number: $pr) {
        reviewThreads(first: 100) {
          nodes {
            id
            isResolved
            comments(first: 10) {
              nodes {
                databaseId
                author { login }
                body
                path
                line
              }
            }
          }
        }
      }
    }
  }' -f owner="$owner" -f repo="$repo" -F pr=$pr_number)

# Extract ONLY unresolved OpenCode threads
# Key distinction: isResolved=false means needs verification, regardless of replies
unresolved_threads=$(echo "$thread_data" | jq -r '
  .data.repository.pullRequest.reviewThreads.nodes[] |
  select(.isResolved == false) |
  select(.comments.nodes[0].body | contains("ðŸ¤– Generated by OpenCode")) |
  {
    threadId: .id,
    commentId: .comments.nodes[0].databaseId,
    path: .comments.nodes[0].path,
    line: .comments.nodes[0].line,
    body: .comments.nodes[0].body
  }')

# For EACH unresolved thread - verify autonomously
echo "$unresolved_threads" | jq -c '.' | while read -r thread; do
  thread_id=$(echo "$thread" | jq -r '.threadId')
  comment_id=$(echo "$thread" | jq -r '.commentId')
  file_path=$(echo "$thread" | jq -r '.path')
  line_num=$(echo "$thread" | jq -r '.line')
  
  # Read current code at commented location and verify
  # If FIXED: Reply in-thread + mark resolved
  gh api "repos/${repo_info}/pulls/${pr_number}/comments" \
    --method POST \
    --field body="âœ… **Verified - Addressed**

The issue has been fixed. The code now:
[specific verification of what changed]

Marking as resolved.

---
*ðŸ¤– Re-verified by OpenCode*" \
    --field in_reply_to=$comment_id
  
  # Mark thread as resolved using GraphQL
  gh api graphql -f query='
    mutation($threadId: ID!) {
      resolveReviewThread(input: {threadId: $threadId}) {
        thread { isResolved }
      }
    }' -f threadId="$thread_id"
  
  # If NOT FIXED: Reply explaining what's still wrong, leave unresolved
done

# Review new/changed code for additional issues
# If NEW issues â†’ post in-thread comments

# Determine verification status
all_satisfied=true  # Based on verification results
has_new_comments=false  # Based on new issues found

# Post verification summary if all concerns addressed
if [ "$all_satisfied" = true ] && [ "$has_new_comments" = false ]; then
  # âœ… All previous issues resolved AND no new issues â†’ Post verification comment
  gh pr comment $pr_number --body "## âœ… Re-Review Complete - All Concerns Addressed

**All Issues Resolved**:
- âœ… All [X] previous threads verified and resolved
- âœ… No new issues found in recent changes

**Verification Summary**:
| Original Issue | File:Line | Status | Verification |
|---------------|-----------|--------|--------------|
| [issue 1] | file.ts:42 | âœ… Resolved | [how it was fixed] |
| [issue 2] | file.go:57 | âœ… Resolved | [how it was fixed] |

All feedback has been satisfactorily implemented. **Ready for human approval**.

---
*ðŸ¤– Re-reviewed by OpenCode*"
  
  echo "âœ… All issues resolved - verification summary posted"
else
  # âŒ Some issues remain OR new issues found
  echo "âš ï¸  Outstanding issues remain or new issues found"
  echo "   - Author must address remaining issues"
  echo "   - Unresolved threads left open for author to review"
fi
```

**Key implementation notes**:
- Suggestion blocks: Use `\`\`\`suggestion` (no language specifier for "Apply" button)
- Every comment MUST end with: `---\n*ðŸ¤– Generated by OpenCode*`
- Use `-F field=@file` or `-f field=value` instead of embedding in JSON
- Re-reviews: Use in-thread replies with `--field in_reply_to=$thread_id`
- Thread resolution: Use GraphQL `resolveReviewThread` mutation
- Verification: Use `gh pr comment` to post standalone summary (NEVER approve directly)

## GraphQL Thread Resolution Reference

```bash
# Get all review threads with their IDs
thread_data=$(gh api graphql -f query='
  query($owner: String!, $repo: String!, $pr: Int!) {
    repository(owner: $owner, name: $repo) {
      pullRequest(number: $pr) {
        reviewThreads(first: 100) {
          nodes {
            id
            isResolved
            comments(first: 10) {
              nodes {
                databaseId
                body
              }
            }
          }
        }
      }
    }
  }' -f owner="$owner" -f repo="$repo" -F pr=$pr_number)

# Resolve each satisfied thread
for comment_id in "${satisfied_comment_ids[@]}"; do
  thread_id=$(echo "$thread_data" | jq -r \
    ".data.repository.pullRequest.reviewThreads.nodes[] | 
     select(.comments.nodes[].databaseId == $comment_id) | .id")
  
  if [ -n "$thread_id" ] && [ "$thread_id" != "null" ]; then
    gh api graphql -f query='
      mutation($threadId: ID!) {
        resolveReviewThread(input: {threadId: $threadId}) {
          thread { isResolved }
        }
      }' -f threadId="$thread_id"
    
    echo "âœ… Resolved thread for comment $comment_id"
  fi
done
```
