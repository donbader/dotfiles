# Comment Templates

Every comment MUST end with `---\n*ü§ñ Generated by OpenCode*`

**Confidence-Based Commenting**: Use the appropriate template based on confidence level from Phase 5 (Two-Pass Review).

## High Confidence Critical Issue (>90% confidence)

Use ONLY when:
- Pattern is demonstrably dangerous (security, data loss)
- Pattern is NOT common in codebase (<2 occurrences)
- No explanatory comments near code
- No relevant context in PR description

```markdown
üö® **Critical - Security**

**Issue**: [e.g., SQL injection vulnerability]

**Why critical**: [Security risk and attack vector]

**Fix**:
\`\`\`suggestion
// Secure implementation
const query = 'SELECT * FROM users WHERE id = ?';
const result = await db.query(query, [userId]);
\`\`\`

**Learning**: [Security principle or best practice]

**References**: [OWASP link or codebase example if relevant]

---
*ü§ñ Generated by OpenCode*
```

## Medium Confidence Important Issue (60-90% confidence)

Use when:
- Potential issue but pattern exists in 3+ similar files
- OR PR description mentions constraints/trade-offs  
- OR seems problematic but missing key context

```markdown
‚ö†Ô∏è **Important - Potential Correctness Issue** (Please verify)

**Pattern observed**: [e.g., State updates even when cache write fails]

**Standard concern**: [Why this is usually wrong]

**However, I noticed**:
- This pattern appears in 5 other files in this directory (e.g., `file1.go:89`, `file2.go:42`)
- PR description mentions "out of order" blocks
- [Other context from Phase 3 analysis]

**Context I'm missing**:
- [ ] Is the RPC stream replayable? (Affects whether this causes data loss)
- [ ] What happens when Redis is down for >5 minutes?
- [ ] Is there monitoring for cache write failures?

**Possible solutions (depends on context)**:

**Scenario A: If RPC is replayable**
\`\`\`suggestion
// Retry queue for failed cache writes
if err != nil {
    t.retryQueue = append(t.retryQueue, nextBlock)
    break
}
\`\`\`

**Scenario B: If RPC is one-time stream** (blocks won't replay)
\`\`\`suggestion
// Current approach is correct - just add explanatory comment:
// NOTE: We update state even on cache failure because:
// 1. RPC stream is not replayable (block won't come again)
// 2. Keeping in pending causes memory leak
// 3. System self-heals when Redis recovers
if err != nil {
    baasrollbar.Error(err)
}
t.lastConsecutive = nextBlock
\`\`\`

Could you clarify which scenario applies?

**Learning**: When persistence and in-memory state interact, the correct pattern depends on whether the data source is replayable.

---
*ü§ñ Generated by OpenCode*
```

## Low Confidence Suggestion (40-60% confidence)

Use when:
- Pattern appears in 5+ files (likely intentional)
- OR author has nearby comment but it could be clearer
- OR optimization that might not matter

```markdown
üí° **Suggestion - Clarify Trade-off**

**Observation**: State updates even when cache write fails (line 156).

**Context**: I noticed this same pattern in 7 other subscription files in this directory:
- `block_number_recording_subscription.go:89`
- `solana_block_number_recording_subscription.go:127`
- [others]

This suggests it's an intentional design pattern for arkcrawler subscriptions.

**Suggestion**: Add a comment explaining the trade-off for future reviewers:

\`\`\`suggestion
// NOTE: We update state even on cache failure because:
// 1. RPC blocks arrive out-of-order and are not replayable (see STXSUP-2427)
// 2. Keeping failed blocks in pending causes memory leak  
// 3. Cache syncs with memory state on next successful write
// 4. Temporary cache staleness is acceptable for this system
err := cache.SetLastCrawledBlockNumber(ctx, nextBlock)
if err != nil {
    baasrollbar.Error(errors.Errorf("failed to record..."))
}
t.lastConsecutive = nextBlock
delete(t.pending, nextBlock)
\`\`\`

**Why this helps**: Preserves the reasoning and prevents future reviewers from flagging this as a bug.

---
*ü§ñ Generated by OpenCode*
```

## Question (< 40% confidence)

Use when:
- Unclear if pattern is bug or intentional design
- Missing critical context about system architecture
- Need author to explain design decision

```markdown
‚ùì **Question - Design Decision**

**Observation**: I noticed state is updated even when cache write fails (line 156).

**Why I'm asking**: 
In typical systems, this could cause split-brain where memory state diverges from persisted state. However, I see:
- Your comment on line 133 says "Only update state after successful cache write"
- But the code continues execution after error
- Similar pattern exists in `block_number_recording_subscription.go:89`

**Possible explanations**:
1. **RPC stream is not replayable** ‚Üí Must process block immediately despite cache failure
2. **Self-healing system** ‚Üí Cache syncs from memory on next successful write
3. **Temporary inconsistency acceptable** ‚Üí Liveness prioritized over consistency

Could you clarify:
- Is the RPC stream replayable?
- How does the system recover when Redis is down?
- Is there a specific reason this pattern is used across subscriptions?

Understanding this will help me provide better recommendations!

---
*ü§ñ Generated by OpenCode*
```

## Security Issue (Critical - High Confidence)

**Use ONLY for clear security vulnerabilities with no valid use case**

```markdown
üö® **Critical - Security**

**Issue**: [e.g., SQL injection vulnerability]

**Why critical**: [Security risk and attack vector]

**Fix**:
\`\`\`suggestion
// Secure implementation
const query = 'SELECT * FROM users WHERE id = ?';
const result = await db.query(query, [userId]);
\`\`\`

**Learning**: [Security principle or best practice]

**References**: [OWASP link or codebase example if relevant]

---
*ü§ñ Generated by OpenCode*
```

## Performance Issue (Important)

```markdown
‚ö†Ô∏è **Important - Performance**

**Issue**: [e.g., N+1 query - creates 101 DB calls for 100 posts]

**Why this matters**: [Performance impact with numbers]

**Fix**:
\`\`\`suggestion
// Batch fetch in one query
const postIds = posts.map(p => p.id);
const allComments = await db.query(
  'SELECT * FROM comments WHERE post_id IN (?)',
  [postIds]
);
\`\`\`

**Impact**: [Quantified - "101 queries ‚Üí 2 queries (50x faster)"]

**Learning**: [Performance principle]

---
*ü§ñ Generated by OpenCode*
```

## Architecture/Design (Important)

```markdown
‚ö†Ô∏è **Important - Architecture**

**Issue**: [e.g., Business logic in controller layer]

**Why this matters**: [Maintainability/testability impact]

**Fix**:
\`\`\`suggestion
// Extract to service layer
export class UserController {
  constructor(private userService: UserService) {}
  
  async createUser(req, res) {
    const user = await this.userService.createUser(req.body);
    res.json(user);
  }
}
\`\`\`

**Benefits**: [Testability, reusability, clarity]

**Learning**: [Design principle]

---
*ü§ñ Generated by OpenCode*
```

## Readability (Suggestion)

```markdown
üí° **Suggestion - Readability**

**Why**: [e.g., "Descriptive names make code self-documenting"]

**Suggestion**:
\`\`\`suggestion
const activeUserProfiles = data
  .filter(item => item.status === 1)
  .map(item => item.value);
\`\`\`

**Principle**: Code is read 10x more than written - optimize for clarity

---
*ü§ñ Generated by OpenCode*
```

## Question/Discussion

```markdown
‚ùì **Question - Design Decision**

I noticed [observation]. Was this because [potential reason]?

\`\`\`typescript
[code in question]
\`\`\`

**Trade-offs**:
- Current approach: [pros/cons]
- Alternative: [pros/cons]

Would love to understand your reasoning!

---
*ü§ñ Generated by OpenCode*
```

## Praise

```markdown
‚úÖ **Great Implementation**

[Specific praise about what's done well]

\`\`\`typescript
[the good code]
\`\`\`

[Why this is good - principle followed, problem solved elegantly]

---
*ü§ñ Generated by OpenCode*
```
