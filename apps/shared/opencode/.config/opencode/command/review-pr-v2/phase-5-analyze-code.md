# Phase 4: Analyze Code

Analyze code directly. Use Task tool only when searching patterns across many files.

**Review scope based on mode**:

**First Review** - Review entire PR:
- Use diff range: `${base_branch}..HEAD`
- Comprehensive review of all changes
- Present to user before posting

**Re-Review** - Verify unresolved threads + review new commits:
- First verify each unresolved thread (see verification logic below)
- Then review new commits: `${last_review_commit}..HEAD`
- Focus on unresolved issues and new changes

**Incremental Review** - Review only new commits:
- Use diff range: `${last_review_commit}..HEAD`
- More lenient - focus on critical issues only
- Skip verification (all previous threads already resolved)
- Smaller scope = faster review

**Priority categories**:

**1. Security & Bugs** üö® (Always comment if found)
- Security vulnerabilities (SQL injection, XSS, auth bypasses)
- Logic errors, null/undefined handling issues
- Race conditions, deadlocks, resource leaks
- Breaking changes to public APIs

**2. Performance** ‚ö†Ô∏è (Significant impact only)
- N+1 query problems
- Inefficient algorithms (O(n¬≤) when O(n) exists)
- Memory leaks, unnecessary allocations

**3. Architecture & Design** ‚ö†Ô∏è (Established pattern violations)
- Violations of project patterns
- Separation of concerns issues
- Inconsistent error handling

**4. Testing** üí° (New functionality without tests)
- Missing tests for new features
- Insufficient edge case coverage

**5. Readability** üí° (Truly confusing code only)
- Confusing variable names or logic
- Missing documentation for public APIs

**For re-reviews**, first verify previous comments:

1. **Fetch threads with resolution status using GraphQL**:
   - Use `reviewThreads` query to get `isResolved` status for each thread
   - Filter to only unresolved threads (`isResolved: false`)
   - Extract OpenCode-authored comments from unresolved threads
   - **Do NOT** use REST API comment replies as a proxy for resolution status

2. **For each unresolved thread**:
   - Read file at specified line and surrounding context (¬±20 lines)
   - Compare current code against described issue
   - Determine status: ‚úÖ Resolved | ‚ö†Ô∏è Partial | ‚ùå Not Addressed | üÜï New Issue

3. **Build verification summary** for each:
   ```
   Previous: "üö® SQL injection vulnerability in login query"
   File: auth.ts:42
   Original issue: String concatenation for SQL query
   Current code: Parameterized query with placeholders
   Verification: ‚úÖ RESOLVED - Properly implemented parameterized queries
   ```

4. **Calculate readiness**:
   - All critical issues resolved?
   - All important issues resolved?
   - No new issues found?
   - If YES to all ‚Üí Ready for approval

**Thread resolution logic**:
```bash
# CORRECT: Check isResolved field from GraphQL
unresolved_threads=$(echo "$thread_data" | jq -r '
  .data.repository.pullRequest.reviewThreads.nodes[] |
  select(.isResolved == false) |
  select(.comments.nodes[0].body | contains("ü§ñ Generated by OpenCode"))')

# INCORRECT: Checking for reply comments
# This is wrong because threads can have replies but still be unresolved
threads_with_replies=$(gh api "repos/${repo}/pulls/${pr}/comments" | \
  jq 'select(.in_reply_to_id != null)')  # ‚ùå DON'T DO THIS
```
